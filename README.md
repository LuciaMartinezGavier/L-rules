# L-rules
L-RULES is (will be) a static analysis rule engine designed to identify semantic patterns in C code.

## Problem Statement
In the realm of cybersecurity, robust static analysis tools play a crucial role in identifying vulnerabilities and threats. Prominent examples include Semgrep and Weggli, which are powerful aids in detecting potential risks within codebases.

Our focus lies specifically on the detection of vulnerabilities in C code. However, the intricacies of C grammar introduce significant challenges, as various syntactical forms can express the same code logic. Existing static analysis tools that emphasize syntax may prove inadequate for creating concise rules that encompass all possible representations.
Furthermore, the specificity of rules generated by these tools, which often rely on exact word matches, results in limitations when considering code behavior rather than just syntax.

The complexity of the C grammar and the limitations of syntax-centric tools underscore the need for an advanced rule engine that supports semantic analysis. The importance of this lies in the ability to detect vulnerabilities and threats based on code semantics, alleviating the burden of accounting for diverse syntactical variations.

A rule engine capable of semantic analysis would enable the formulation of rules grounded in axioms derived from specifications such as the UEFI specification. This approach ensures the creation of rules that are both comprehensive and succinct, as they target semantic patterns rather than being dependent on the nuances of C syntax.

# Prolog Proof of Concept
We've provided a Prolog example demonstrating how L-RULES would detect potential stack overflow vulnerabilities through the `getVariable` UEFI function.


## Code representation

To be able to do queries about the code we need an intermediate representation that can simplify the task.

In this case, we use something very similar to an AST, where the nodes represent operatitons and the children of the node are the operands.

This is used to represent the overall structure of the code. But we also need some semantic information about the code, for example if a variable is stored in the stack or heap, and if there is some buffer allocation.

We define:
```prolog
function_def(function_name, params, body)
function_call(function_name, params)
arg(actual_parameter, theorical_parameter) used for function calls
assign(lvalue, rvalue)
decl(variable_name, stack | heap)
buffer_alloc(buffer, size)
```
